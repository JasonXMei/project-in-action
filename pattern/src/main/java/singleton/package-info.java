/**
 * 1、定义
 * 作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。
 * 
 * Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；
 * 为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例
 * 
 * 2、单例特点
 * 1）单例类只能有一个实例。
 * 2）单例类必须自己创建自己的唯一实例。
 * 3）单例类必须给所有其他对象提供这一实例。
 * 
 * 3、饿汉式单例vs懒汉式单例
 * 1）饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。
 * 2）懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。
 * 
 * 4、优化懒汉式单例
 * 1）双重检查加锁（不建议）
 * 并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，
 * 进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下
 * 进行判断所浪费的时间;“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写
 * 都是直接操作共享内存，从而确保多个线程能正确的处理该变量，由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。
 * 因此一般建议，没有特别的需要，不要使用。
 * 2）IoDH(Initialization On Demand Holder)技术（静态内部类）
 * 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，实现了延迟加载
 * 第一次调用getInstance()时将加载内部类InnerClass，在该内部类中定义了一个static类型的变量instance，
 * 此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。
 * 由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。
 * 3）枚举
 * 在枚举中我们明确限制构造方法为私有，在我们访问枚举实例时会执行构造方法，同时每个枚举实例都是static final类型的，也就表明只能被实例化一次。
 * 在调用构造方法时，我们的单例被实例化。也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。
 * 
 * 5、优缺点
 * 优点：
 * 1）提供了对唯一实例的受控访问；
 * 2）由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能；
 * 3）允许可变数目的实例。
 * 缺点：
 * 1）由于单利模式中没有抽象层，因此单例类的扩展有很大的困难；
 * 2）单例类的职责过重，在一定程度上违背了“单一职责原则”；
 * 
 * 6、使用场景
 * 1）任务管理器，回收站，打印机；
 * 2）网站的计数器；
 * 3）共享日志。
 */
package singleton;
